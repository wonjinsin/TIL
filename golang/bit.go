package main

import (
	"fmt"
)

func main() {
	// &연산(AND)
	// 두 비트가 모두 1일 때만 1을 반환
	// 0 & 0 = 0
	// 0 & 1 = 0
	// 1 & 0 = 0
	// 1 & 1 = 1
	// 1010 & 1100 = 1000
	// 1010 & 1100 = 1000
	// 컴퓨터는 보통 고정된 비트 크기(예: 8비트, 16비트, 32비트)로 데이터를 처리합니다. 따라서 비트 연산을 설명할 때, 일반적으로 동일한 자리 수로 맞춰서 보여주는 것이 직관적입니다.
	// 예를 들어, 5를 4비트로 표현하면 0101, 3을 4비트로 표현하면 0011이 됩니다.
	// 컴퓨터는 메모리에서 데이터를 처리할 때 항상 고정된 비트 크기로 데이터를 저장합니다.
	// 예를 들어, 8비트 시스템에서는 5는 00000101로, 3은 00000011로 저장됩니다.
	// 따라서 비트 연산 시에도 이런 고정 크기를 가정하고 이해하는 것이 자연스럽습니다.
	a := 5             // 0101
	b := 3             // 0011
	fmt.Println(a & b) // 1, 0001

	// |연산(OR)
	// 두 비트 중 하나라도 1이면 1을 반환
	// 0 | 0 = 0
	// 0 | 1 = 1
	// 1 | 0 = 1
	// 1 | 1 = 1
	a = 5              // 0101
	b = 3              // 0011
	fmt.Println(a | b) // 7, 0111

	// ^연산(XOR)
	// 두 비트가 다를 때 1을 반환
	// 0 ^ 0 = 0
	// 0 ^ 1 = 1
	// 1 ^ 0 = 1
	// 1 ^ 1 = 0
	a = 5              // 0101
	b = 3              // 0011
	fmt.Println(a ^ b) // 6, 0110

	// ^연산(NOT)
	// 비트를 반전
	// ~0 = 1
	// ~1 = 0
	a = 5           // 0101
	fmt.Println(^a) // -6, -0110

	// <<연산(Left Shift)
	// 비트를 왼쪽으로 이동
	// 00000101 << 1 = 00001010
	fmt.Println("start left shift")
	t := int8(80)       // 01010000
	fmt.Println(t << 1) // -96, 10100000
	fmt.Println(t << 2) // 64, 01000000
	fmt.Println(t << 3) // -128, 10000000, 1 + 2 + 4 + 8 + 16 + 32 + 64 + 1에 -를 붙여줌, 앞에가 1이 되면 -라는 의미, 128의 보수, uint8로 표현하면 128이 됨
	fmt.Println(t << 4) // 0, 00000000
	fmt.Println(t << 5) // 0, 00000000

	// >>연산(Right Shift)
	// 비트를 오른쪽으로 이동, 오른쪽 비트는 사라짐
	// 00000101 >> 1 = 00000010
	fmt.Println(a >> 1) // 2, 00000010
	fmt.Println(a >> 2) // 1, 00000001
	fmt.Println(a >> 3) // 0, 00000000

	a = -8
	a = a >> 1
	fmt.Println(a) // -4

	// 2의 보수 표현
	// 2의 보수 표현은 음수를 표현하는 방법 중 하나로, 양수의 2의 보수는 그 양수의 비트를 반전시킨 후 1을 더하는 것입니다.
	// 예를 들어, 5의 2의 보수는 -5가 됩니다.
	// 5 = 0101, -5는 1010 + 1 = 1011, 1011은 맨 왼쪽이 1이기 때문에 일단 앞에 -를 붙이고, 보수를 구해서(0100 + 1 = 0101, 5) 앞에 -를 붙이면 -5가 됨

	// 5 - 3은 5 + (-3)으로 계산할 수 있음
	// 5 = 0101, 3은 0011의 2의 보수는 1100 + 1 = 1101, 0101 + 1101 = 10010, 10010은 4비트이기 때문에 왼쪽은 제외하고(캐리 비트, 오버플로우) 0010이 됨, 0010은 2가 됨

	// 3 - 5는 3 + (-5)로 계산할 수 있음
	// 3 = 0011, 5는 0101의 2의 보수는 1010 + 1 = 1011, 0011 + 1010 = 1101, 4비트 인데 맨왼쪽이 1이기 때문에 일단 앞에 -를 붙이고, 보수를 구해서(0010 + 1 = 0011, 3) 앞에 -를 붙이면 -3이 됨

	a = 7              // 0111
	b = -2             // 0010, 2의 보수는 1101 + 1 = 1110
	fmt.Println(a + b) // 0111 + 1110 = 10101, 4비트기 때문에 맨왼쪽은 제외하고 0101이 됨, 0101은 5가 됨
}
