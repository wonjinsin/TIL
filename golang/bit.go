package main

import (
	"fmt"
)

func main() {
	// &연산(AND)
	// 두 비트가 모두 1일 때만 1을 반환
	// 0 & 0 = 0
	// 0 & 1 = 0
	// 1 & 0 = 0
	// 1 & 1 = 1
	// 1010 & 1100 = 1000
	// 1010 & 1100 = 1000
	// 컴퓨터는 보통 고정된 비트 크기(예: 8비트, 16비트, 32비트)로 데이터를 처리합니다. 따라서 비트 연산을 설명할 때, 일반적으로 동일한 자리 수로 맞춰서 보여주는 것이 직관적입니다.
	// 예를 들어, 5를 4비트로 표현하면 0101, 3을 4비트로 표현하면 0011이 됩니다.
	// 컴퓨터는 메모리에서 데이터를 처리할 때 항상 고정된 비트 크기로 데이터를 저장합니다.
	// 예를 들어, 8비트 시스템에서는 5는 00000101로, 3은 00000011로 저장됩니다.
	// 따라서 비트 연산 시에도 이런 고정 크기를 가정하고 이해하는 것이 자연스럽습니다.
	a := 5             // 0101
	b := 3             // 0011
	fmt.Println(a & b) // 1, 0001

	// |연산(OR)
	// 두 비트 중 하나라도 1이면 1을 반환
	// 0 | 0 = 0
	// 0 | 1 = 1
	// 1 | 0 = 1
	// 1 | 1 = 1
	a = 5              // 0101
	b = 3              // 0011
	fmt.Println(a | b) // 7, 0111

	// ^연산(XOR)
	// 두 비트가 다를 때 1을 반환
	// 0 ^ 0 = 0
	// 0 ^ 1 = 1
	// 1 ^ 0 = 1
	// 1 ^ 1 = 0
	a = 5              // 0101
	b = 3              // 0011
	fmt.Println(a ^ b) // 6, 0110

	// ^연산(NOT)
	// 비트를 반전
	// ~0 = 1
	// ~1 = 0
	a = 5           // 0101
	fmt.Println(^a) // -6, -0110

	// <<연산(Left Shift)
	// 비트를 왼쪽으로 이동
	// 00000101 << 1 = 00001010
	fmt.Println("start left shift")
	t := int8(80)       // 01010000
	fmt.Println(t << 1) // -96, 10100000
	fmt.Println(t << 2) // 64, 01000000
	fmt.Println(t << 3) // -128, 10000000, 1 + 2 + 4 + 8 + 16 + 32 + 64 + 1에 -를 붙여줌, 앞에가 1이 되면 -라는 의미, 128의 보수, uint8로 표현하면 128이 됨
	fmt.Println(t << 4) // 0, 00000000
	fmt.Println(t << 5) // 0, 00000000

	// >>연산(Right Shift)
	// 비트를 오른쪽으로 이동, 오른쪽 비트는 사라짐
	// 00000101 >> 1 = 00000010
	fmt.Println(a >> 1) // 2, 00000010
	fmt.Println(a >> 2) // 1, 00000001
	fmt.Println(a >> 3) // 0, 00000000

	a = -8
	a = a >> 1
	fmt.Println(a) // -4

	// 2의 보수 표현
	// 2의 보수 표현은 음수를 표현하는 방법 중 하나로, 양수의 2의 보수는 그 양수의 비트를 반전시킨 후 1을 더하는 것입니다.
	// 예를 들어, 5의 2의 보수는 -5가 됩니다.
	// 5의 2의 보수는 0101을 반전시킨 후 1을 더하면 1010이 되고, 이를 다시 10진수로 변환하면 -5가 됩니다.
	// 따라서 -8 >> 1 = -4가 됩니다.
	// 덧셈과 뺄셈이 동일한 연산으로 처리 가능
	// 예를 들어, 7 - 5는 7 + (-5)로 계산할 수 있습니다.
	// 이는 2의 보수 표현 덕분에 가능하며, 하드웨어 설계를 단순하게 만듭니다.
	// 0111 (7)
	// + 1011 (-5)
	// 10010 (2)
	// 10010을 다시 10진수로 변환하면 2가 됩니다.(결과값의 4비트만 사용, 4비트로 계산을 했는데 오버플로우가 발생헀기때문에, 이건 사실 덧셈도 마친가지긴 함)
	// 따라서 7 - 5 = 2가 됩니다.
	// 7 - 8을 계산하는 법
	// 7 - 8 = 7 + (-8)
	// 7 = 0111
	// 8 = 1000, 2의 보수는 0111 + 1 = -8
	// 0111 + (1000) = 1111
	// 1111의 2의 보수는 0001(0000 + 1 = 0001)
	// 따라서 7 - 8 = 7 + (-8) = -1
	// -3은 1101
	// 1101의 2의 보수는 0010 + 1 = 0011
	a = 7
	b = -5
	fmt.Println(a + b) // 2, 0010
}
